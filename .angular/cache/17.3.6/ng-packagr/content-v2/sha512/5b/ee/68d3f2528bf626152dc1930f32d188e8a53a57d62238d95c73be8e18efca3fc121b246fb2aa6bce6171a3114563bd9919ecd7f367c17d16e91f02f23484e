{"hash":"92ea8783d2f10161e5673018ed1d3544f7563be5","fesm2022":[{"exports":["MutexFastLockConfig","MutexFastLockModule","MutexFastLockService","MutexLockStats"],"facadeModuleId":"D:\\Dev\\DevLearninGRepo\\mutex-fast-lock\\dist\\mutex-fast-lock\\esm2022\\devlearning-mutex-fast-lock.mjs","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["D:\\Dev\\DevLearninGRepo\\mutex-fast-lock\\dist\\mutex-fast-lock\\esm2022\\lib\\models\\mutex-fast-lock-config.mjs","D:\\Dev\\DevLearninGRepo\\mutex-fast-lock\\dist\\mutex-fast-lock\\esm2022\\lib\\models\\mutex-lock-stats.mjs","D:\\Dev\\DevLearninGRepo\\mutex-fast-lock\\dist\\mutex-fast-lock\\esm2022\\lib\\mutex-fast-lock-config.injector.mjs","D:\\Dev\\DevLearninGRepo\\mutex-fast-lock\\dist\\mutex-fast-lock\\esm2022\\lib\\models\\lock-item.mjs","D:\\Dev\\DevLearninGRepo\\mutex-fast-lock\\dist\\mutex-fast-lock\\esm2022\\lib\\mutex-fast-lock.service.mjs","D:\\Dev\\DevLearninGRepo\\mutex-fast-lock\\dist\\mutex-fast-lock\\esm2022\\lib\\mutex-fast-lock.module.mjs","D:\\Dev\\DevLearninGRepo\\mutex-fast-lock\\dist\\mutex-fast-lock\\esm2022\\public-api.mjs","D:\\Dev\\DevLearninGRepo\\mutex-fast-lock\\dist\\mutex-fast-lock\\esm2022\\devlearning-mutex-fast-lock.mjs"],"name":"devlearning-mutex-fast-lock","type":"chunk","dynamicImports":[],"fileName":"devlearning-mutex-fast-lock.mjs","implicitlyLoadedBefore":[],"importedBindings":{"@angular/core":["InjectionToken","*","Injectable","Inject","NgModule"],"rxjs":["Observable"]},"imports":["@angular/core","rxjs"],"modules":{"D:\\Dev\\DevLearninGRepo\\mutex-fast-lock\\dist\\mutex-fast-lock\\esm2022\\lib\\models\\mutex-fast-lock-config.mjs":{"code":"class MutexFastLockConfig {\n    lockPrefix;\n    timeout;\n    debugEnabled;\n}","originalLength":662,"removedExports":[],"renderedExports":["MutexFastLockConfig"],"renderedLength":76},"D:\\Dev\\DevLearninGRepo\\mutex-fast-lock\\dist\\mutex-fast-lock\\esm2022\\lib\\models\\mutex-lock-stats.mjs":{"code":"class MutexLockStats {\n    restartCount;\n    locksLost;\n    contentionCount;\n    acquireDuration;\n    acquireStart;\n    acquireEnd;\n    lockStart;\n    lockEnd;\n    lockDuration;\n}","originalLength":1081,"removedExports":[],"renderedExports":["MutexLockStats"],"renderedLength":179},"D:\\Dev\\DevLearninGRepo\\mutex-fast-lock\\dist\\mutex-fast-lock\\esm2022\\lib\\mutex-fast-lock-config.injector.mjs":{"code":"const MUTEX_FAST_LOCK_CONFIG = new InjectionToken('MUTEX_FAST_LOCK_CONFIG');","originalLength":918,"removedExports":[],"renderedExports":["MUTEX_FAST_LOCK_CONFIG"],"renderedLength":76},"D:\\Dev\\DevLearninGRepo\\mutex-fast-lock\\dist\\mutex-fast-lock\\esm2022\\lib\\models\\lock-item.mjs":{"code":"class LockItem {\n    clientId;\n    expiresAt;\n}","originalLength":521,"removedExports":[],"renderedExports":["LockItem"],"renderedLength":47},"D:\\Dev\\DevLearninGRepo\\mutex-fast-lock\\dist\\mutex-fast-lock\\esm2022\\lib\\mutex-fast-lock.service.mjs":{"code":"class MutexFastLockService {\n    _config;\n    _clientId;\n    _xPrefix;\n    _yPrefix;\n    constructor(_config) {\n        this._config = _config;\n        this._clientId = this._generateRandomId();\n        this._xPrefix = _config.lockPrefix + '_X_';\n        this._yPrefix = _config.lockPrefix + '_Y_';\n        let that = this;\n        window.addEventListener(\"beforeunload\", function (ev) {\n            var arr = [];\n            for (var i = 0; i < localStorage.length; i++) {\n                if (localStorage.key(i).indexOf(that._xPrefix) == 0\n                    || localStorage.key(i).indexOf(that._yPrefix) == 0) {\n                    arr.push(localStorage.key(i));\n                }\n            }\n            for (var i = 0; i < arr.length; i++) {\n                localStorage.removeItem(arr[i]);\n            }\n        });\n    }\n    lock(key, timeout = -1) {\n        let that = this;\n        if (timeout == -1)\n            timeout = this._config.timeout;\n        let xLock = that._xPrefix + key;\n        let yLock = that._yPrefix + key;\n        let lockStats = new MutexLockStats();\n        that.resetStats(lockStats);\n        this._config.debugEnabled ?? console.debug('Attempting to acquire Lock on \"%s\" using FastMutex instance \"%s\"', key, this._clientId);\n        lockStats.acquireStart = new Date().getTime();\n        //return new Promise(function (resolve, reject) {\n        return new Observable(subscriber => {\n            // we need to differentiate between API calls to lock() and our internal\n            // recursive calls so that we can timeout based on the original lock() and\n            // not each subsequent call.  Therefore, create a new function here within\n            // the promise closure that we use for subsequent calls:\n            let acquireLock = function acquireLock(key) {\n                that._releaseExpiredLock(xLock);\n                that._releaseExpiredLock(yLock);\n                var elapsedTime = new Date().getTime() - lockStats.acquireStart;\n                if (elapsedTime >= timeout) {\n                    that._config.debugEnabled ?? console.debug('Lock on \"%s\" could not be acquired within %sms by FastMutex client \"%s\"', key, timeout, that._clientId);\n                    subscriber.error(new Error('Lock could not be acquired within ' + timeout + 'ms'));\n                }\n                that._setItem(xLock, that._clientId, timeout);\n                // if y exists, another client is getting a lock, so retry in a bit\n                var lsY = that._getItem(yLock, timeout);\n                if (lsY) {\n                    that._config.debugEnabled ?? console.debug('Lock exists on Y (%s), restarting...', lsY);\n                    lockStats.restartCount++;\n                    setTimeout(function () {\n                        return acquireLock(key);\n                    }, 10);\n                    return;\n                }\n                // ask for inner lock\n                that._setItem(yLock, that._clientId, timeout);\n                // if x was changed, another client is contending for an inner lock\n                var lsX = that._getItem(xLock, timeout);\n                if (lsX !== that._clientId) {\n                    lockStats.contentionCount++;\n                    that._config.debugEnabled ?? console.debug('Lock contention detected. X=\"%s\"', lsX);\n                    // Give enough time for critical section:\n                    setTimeout(function () {\n                        lsY = that._getItem(yLock, timeout);\n                        if (lsY === that._clientId) {\n                            // we have a lock\n                            that._config.debugEnabled ?? console.debug('FastMutex client \"%s\" won the lock contention on \"%s\"', that._clientId, key);\n                            that.resolveWithStats(subscriber, lockStats);\n                        }\n                        else {\n                            // we lost the lock, restart the process again\n                            lockStats.restartCount++;\n                            lockStats.locksLost++;\n                            that._config.debugEnabled ?? console.debug('FastMutex client \"%s\" lost the lock contention on \"%s\" to another process (%s). Restarting...', that._clientId, key, lsY);\n                            setTimeout(function () {\n                                return acquireLock(key);\n                            }, 10);\n                        }\n                    }, 100);\n                    return;\n                }\n                // no contention:\n                that._config.debugEnabled ?? console.debug('FastMutex client \"%s\" acquired a lock on \"%s\" with no contention', that._clientId, key);\n                that.resolveWithStats(subscriber, lockStats);\n            };\n            acquireLock(key);\n        });\n    }\n    release(key) {\n        this._config.debugEnabled ?? console.debug('FastMutex client \"%s\" is releasing lock on \"%s\"', this._clientId, key);\n        let x = this._xPrefix + key;\n        let y = this._yPrefix + key;\n        localStorage.removeItem(x);\n        localStorage.removeItem(y);\n        //that.lockStats.lockEnd = new Date().getTime();\n        //that.lockStats.lockDuration = that.lockStats.lockEnd - that.lockStats.lockStart;\n        //let retStats = angular.copy(that.lockStats);\n        //that.resetStats();\n        //return retStats;\n    }\n    _generateRandomId() {\n        return Math.floor(Math.random() * 10000000000) + '';\n    }\n    resetStats(lockStats) {\n        lockStats.restartCount = 0;\n        lockStats.locksLost = 0;\n        lockStats.contentionCount = 0;\n        lockStats.acquireDuration = 0;\n        lockStats.acquireStart = null;\n    }\n    resolveWithStats(subscriber, stats) {\n        var currentTime = new Date().getTime();\n        stats.acquireEnd = currentTime;\n        stats.acquireDuration = stats.acquireEnd - stats.acquireStart;\n        stats.lockStart = currentTime;\n        subscriber.next(stats);\n        subscriber.complete();\n    }\n    /**\n     * Helper function to wrap all values in an object that includes the time (so\n     * that we can expire it in the future) and json.stringify's it\n     */\n    _setItem(key, clientId, timeout) {\n        let lockItem = new LockItem();\n        lockItem.clientId = clientId;\n        lockItem.expiresAt = new Date().getTime() + timeout;\n        return localStorage.setItem(key, JSON.stringify(lockItem));\n    }\n    /**\n     * Helper function to parse JSON encoded values set in localStorage\n     */\n    _getItem(key, timeout) {\n        var item = localStorage.getItem(key);\n        if (!item)\n            return null;\n        var lockItem = JSON.parse(item);\n        if (new Date().getTime() - lockItem.expiresAt >= timeout) {\n            this._config.debugEnabled ?? console.debug('FastMutex client \"%s\" removed an expired record on \"%s\"', this._clientId, key);\n            localStorage.removeItem(key);\n            return null;\n        }\n        return lockItem.clientId;\n    }\n    _releaseExpiredLock(key) {\n        var item = localStorage.getItem(key);\n        if (!item)\n            return null;\n        var lockItem = JSON.parse(item);\n        if (lockItem.expiresAt <= new Date().getTime()) {\n            this._config.debugEnabled ?? console.debug('FastMutex auto removed an expired record on \"%s\"', key);\n            localStorage.removeItem(key);\n        }\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.3.7\", ngImport: i0, type: MutexFastLockService, deps: [{ token: MUTEX_FAST_LOCK_CONFIG }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.3.7\", ngImport: i0, type: MutexFastLockService, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.3.7\", ngImport: i0, type: MutexFastLockService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: () => [{ type: MutexFastLockConfig, decorators: [{\n                    type: Inject,\n                    args: [MUTEX_FAST_LOCK_CONFIG]\n                }] }] });","originalLength":27432,"removedExports":[],"renderedExports":["MutexFastLockService"],"renderedLength":8141},"D:\\Dev\\DevLearninGRepo\\mutex-fast-lock\\dist\\mutex-fast-lock\\esm2022\\lib\\mutex-fast-lock.module.mjs":{"code":"class MutexFastLockModule {\n    static forRoot(config) {\n        return ({\n            ngModule: MutexFastLockModule,\n            providers: [\n                { provide: MUTEX_FAST_LOCK_CONFIG, useValue: config },\n            ]\n        });\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.3.7\", ngImport: i0, type: MutexFastLockModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.3.7\", ngImport: i0, type: MutexFastLockModule });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.3.7\", ngImport: i0, type: MutexFastLockModule });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.3.7\", ngImport: i0, type: MutexFastLockModule, decorators: [{\n            type: NgModule\n        }] });","originalLength":2535,"removedExports":[],"renderedExports":["MutexFastLockModule"],"renderedLength":846},"D:\\Dev\\DevLearninGRepo\\mutex-fast-lock\\dist\\mutex-fast-lock\\esm2022\\public-api.mjs":{"code":"/*\n * Public API Surface of cnet-mutex-fast-lock\n */","originalLength":1012,"removedExports":[],"renderedExports":[],"renderedLength":52},"D:\\Dev\\DevLearninGRepo\\mutex-fast-lock\\dist\\mutex-fast-lock\\esm2022\\devlearning-mutex-fast-lock.mjs":{"code":"/**\n * Generated bundle index. Do not edit.\n */","originalLength":548,"removedExports":[],"renderedExports":[],"renderedLength":47}},"referencedFiles":[],"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, NgModule } from '@angular/core';\nimport { Observable } from 'rxjs';\n\nclass MutexFastLockConfig {\n    lockPrefix;\n    timeout;\n    debugEnabled;\n}\n\nclass MutexLockStats {\n    restartCount;\n    locksLost;\n    contentionCount;\n    acquireDuration;\n    acquireStart;\n    acquireEnd;\n    lockStart;\n    lockEnd;\n    lockDuration;\n}\n\nconst MUTEX_FAST_LOCK_CONFIG = new InjectionToken('MUTEX_FAST_LOCK_CONFIG');\n\nclass LockItem {\n    clientId;\n    expiresAt;\n}\n\nclass MutexFastLockService {\n    _config;\n    _clientId;\n    _xPrefix;\n    _yPrefix;\n    constructor(_config) {\n        this._config = _config;\n        this._clientId = this._generateRandomId();\n        this._xPrefix = _config.lockPrefix + '_X_';\n        this._yPrefix = _config.lockPrefix + '_Y_';\n        let that = this;\n        window.addEventListener(\"beforeunload\", function (ev) {\n            var arr = [];\n            for (var i = 0; i < localStorage.length; i++) {\n                if (localStorage.key(i).indexOf(that._xPrefix) == 0\n                    || localStorage.key(i).indexOf(that._yPrefix) == 0) {\n                    arr.push(localStorage.key(i));\n                }\n            }\n            for (var i = 0; i < arr.length; i++) {\n                localStorage.removeItem(arr[i]);\n            }\n        });\n    }\n    lock(key, timeout = -1) {\n        let that = this;\n        if (timeout == -1)\n            timeout = this._config.timeout;\n        let xLock = that._xPrefix + key;\n        let yLock = that._yPrefix + key;\n        let lockStats = new MutexLockStats();\n        that.resetStats(lockStats);\n        this._config.debugEnabled ?? console.debug('Attempting to acquire Lock on \"%s\" using FastMutex instance \"%s\"', key, this._clientId);\n        lockStats.acquireStart = new Date().getTime();\n        //return new Promise(function (resolve, reject) {\n        return new Observable(subscriber => {\n            // we need to differentiate between API calls to lock() and our internal\n            // recursive calls so that we can timeout based on the original lock() and\n            // not each subsequent call.  Therefore, create a new function here within\n            // the promise closure that we use for subsequent calls:\n            let acquireLock = function acquireLock(key) {\n                that._releaseExpiredLock(xLock);\n                that._releaseExpiredLock(yLock);\n                var elapsedTime = new Date().getTime() - lockStats.acquireStart;\n                if (elapsedTime >= timeout) {\n                    that._config.debugEnabled ?? console.debug('Lock on \"%s\" could not be acquired within %sms by FastMutex client \"%s\"', key, timeout, that._clientId);\n                    subscriber.error(new Error('Lock could not be acquired within ' + timeout + 'ms'));\n                }\n                that._setItem(xLock, that._clientId, timeout);\n                // if y exists, another client is getting a lock, so retry in a bit\n                var lsY = that._getItem(yLock, timeout);\n                if (lsY) {\n                    that._config.debugEnabled ?? console.debug('Lock exists on Y (%s), restarting...', lsY);\n                    lockStats.restartCount++;\n                    setTimeout(function () {\n                        return acquireLock(key);\n                    }, 10);\n                    return;\n                }\n                // ask for inner lock\n                that._setItem(yLock, that._clientId, timeout);\n                // if x was changed, another client is contending for an inner lock\n                var lsX = that._getItem(xLock, timeout);\n                if (lsX !== that._clientId) {\n                    lockStats.contentionCount++;\n                    that._config.debugEnabled ?? console.debug('Lock contention detected. X=\"%s\"', lsX);\n                    // Give enough time for critical section:\n                    setTimeout(function () {\n                        lsY = that._getItem(yLock, timeout);\n                        if (lsY === that._clientId) {\n                            // we have a lock\n                            that._config.debugEnabled ?? console.debug('FastMutex client \"%s\" won the lock contention on \"%s\"', that._clientId, key);\n                            that.resolveWithStats(subscriber, lockStats);\n                        }\n                        else {\n                            // we lost the lock, restart the process again\n                            lockStats.restartCount++;\n                            lockStats.locksLost++;\n                            that._config.debugEnabled ?? console.debug('FastMutex client \"%s\" lost the lock contention on \"%s\" to another process (%s). Restarting...', that._clientId, key, lsY);\n                            setTimeout(function () {\n                                return acquireLock(key);\n                            }, 10);\n                        }\n                    }, 100);\n                    return;\n                }\n                // no contention:\n                that._config.debugEnabled ?? console.debug('FastMutex client \"%s\" acquired a lock on \"%s\" with no contention', that._clientId, key);\n                that.resolveWithStats(subscriber, lockStats);\n            };\n            acquireLock(key);\n        });\n    }\n    release(key) {\n        this._config.debugEnabled ?? console.debug('FastMutex client \"%s\" is releasing lock on \"%s\"', this._clientId, key);\n        let x = this._xPrefix + key;\n        let y = this._yPrefix + key;\n        localStorage.removeItem(x);\n        localStorage.removeItem(y);\n        //that.lockStats.lockEnd = new Date().getTime();\n        //that.lockStats.lockDuration = that.lockStats.lockEnd - that.lockStats.lockStart;\n        //let retStats = angular.copy(that.lockStats);\n        //that.resetStats();\n        //return retStats;\n    }\n    _generateRandomId() {\n        return Math.floor(Math.random() * 10000000000) + '';\n    }\n    resetStats(lockStats) {\n        lockStats.restartCount = 0;\n        lockStats.locksLost = 0;\n        lockStats.contentionCount = 0;\n        lockStats.acquireDuration = 0;\n        lockStats.acquireStart = null;\n    }\n    resolveWithStats(subscriber, stats) {\n        var currentTime = new Date().getTime();\n        stats.acquireEnd = currentTime;\n        stats.acquireDuration = stats.acquireEnd - stats.acquireStart;\n        stats.lockStart = currentTime;\n        subscriber.next(stats);\n        subscriber.complete();\n    }\n    /**\n     * Helper function to wrap all values in an object that includes the time (so\n     * that we can expire it in the future) and json.stringify's it\n     */\n    _setItem(key, clientId, timeout) {\n        let lockItem = new LockItem();\n        lockItem.clientId = clientId;\n        lockItem.expiresAt = new Date().getTime() + timeout;\n        return localStorage.setItem(key, JSON.stringify(lockItem));\n    }\n    /**\n     * Helper function to parse JSON encoded values set in localStorage\n     */\n    _getItem(key, timeout) {\n        var item = localStorage.getItem(key);\n        if (!item)\n            return null;\n        var lockItem = JSON.parse(item);\n        if (new Date().getTime() - lockItem.expiresAt >= timeout) {\n            this._config.debugEnabled ?? console.debug('FastMutex client \"%s\" removed an expired record on \"%s\"', this._clientId, key);\n            localStorage.removeItem(key);\n            return null;\n        }\n        return lockItem.clientId;\n    }\n    _releaseExpiredLock(key) {\n        var item = localStorage.getItem(key);\n        if (!item)\n            return null;\n        var lockItem = JSON.parse(item);\n        if (lockItem.expiresAt <= new Date().getTime()) {\n            this._config.debugEnabled ?? console.debug('FastMutex auto removed an expired record on \"%s\"', key);\n            localStorage.removeItem(key);\n        }\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.3.7\", ngImport: i0, type: MutexFastLockService, deps: [{ token: MUTEX_FAST_LOCK_CONFIG }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.3.7\", ngImport: i0, type: MutexFastLockService, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.3.7\", ngImport: i0, type: MutexFastLockService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: () => [{ type: MutexFastLockConfig, decorators: [{\n                    type: Inject,\n                    args: [MUTEX_FAST_LOCK_CONFIG]\n                }] }] });\n\nclass MutexFastLockModule {\n    static forRoot(config) {\n        return ({\n            ngModule: MutexFastLockModule,\n            providers: [\n                { provide: MUTEX_FAST_LOCK_CONFIG, useValue: config },\n            ]\n        });\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.3.7\", ngImport: i0, type: MutexFastLockModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.3.7\", ngImport: i0, type: MutexFastLockModule });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.3.7\", ngImport: i0, type: MutexFastLockModule });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.3.7\", ngImport: i0, type: MutexFastLockModule, decorators: [{\n            type: NgModule\n        }] });\n\n/*\n * Public API Surface of cnet-mutex-fast-lock\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MutexFastLockConfig, MutexFastLockModule, MutexFastLockService, MutexLockStats };\n//# sourceMappingURL=devlearning-mutex-fast-lock.mjs.map\n","map":null,"preliminaryFileName":"devlearning-mutex-fast-lock.mjs","sourcemapFileName":"devlearning-mutex-fast-lock.mjs.map"},{"fileName":"devlearning-mutex-fast-lock.mjs.map","needsCodeReference":false,"source":"{\"version\":3,\"file\":\"devlearning-mutex-fast-lock.mjs\",\"sources\":[\"../../../projects/mutex-fast-lock/src/lib/models/mutex-fast-lock-config.ts\",\"../../../projects/mutex-fast-lock/src/lib/models/mutex-lock-stats.ts\",\"../../../projects/mutex-fast-lock/src/lib/mutex-fast-lock-config.injector.ts\",\"../../../projects/mutex-fast-lock/src/lib/models/lock-item.ts\",\"../../../projects/mutex-fast-lock/src/lib/mutex-fast-lock.service.ts\",\"../../../projects/mutex-fast-lock/src/lib/mutex-fast-lock.module.ts\",\"../../../projects/mutex-fast-lock/src/public-api.ts\",\"../../../projects/mutex-fast-lock/src/devlearning-mutex-fast-lock.ts\"],\"sourcesContent\":[\"export class MutexFastLockConfig{\\r\\n  lockPrefix: string;\\r\\n  timeout: number;\\r\\n  debugEnabled: boolean;\\r\\n}\",\"export class MutexLockStats {\\r\\n  restartCount: number;\\r\\n  locksLost: number;\\r\\n  contentionCount: number;\\r\\n  acquireDuration: number;\\r\\n  acquireStart: number;\\r\\n  acquireEnd: number;\\r\\n  lockStart: number;\\r\\n  lockEnd: number;\\r\\n  lockDuration: number;\\r\\n}\",\"import { InjectionToken } from '@angular/core';\\r\\nimport { MutexFastLockConfig } from './models/mutex-fast-lock-config';\\r\\n\\r\\nexport const MUTEX_FAST_LOCK_CONFIG = new InjectionToken<MutexFastLockConfig>('MUTEX_FAST_LOCK_CONFIG');\",\"export class LockItem{\\r\\n  clientId: string;\\r\\n  expiresAt: number;\\r\\n}\",\"import { Inject, Injectable } from '@angular/core';\\r\\nimport { MUTEX_FAST_LOCK_CONFIG } from './mutex-fast-lock-config.injector';\\r\\nimport { MutexFastLockConfig } from './models/mutex-fast-lock-config';\\r\\nimport { MutexLockStats } from './models/mutex-lock-stats';\\r\\nimport { Observable, Subscriber } from 'rxjs';\\r\\nimport { LockItem } from './models/lock-item';\\r\\n\\r\\n@Injectable({\\r\\n  providedIn: 'root'\\r\\n})\\r\\nexport class MutexFastLockService {\\r\\n\\r\\n  private _clientId: string;\\r\\n  private _xPrefix: string;\\r\\n  private _yPrefix: string;\\r\\n\\r\\n  constructor(\\r\\n    @Inject(MUTEX_FAST_LOCK_CONFIG) private readonly _config: MutexFastLockConfig,\\r\\n  ) {\\r\\n    this._clientId = this._generateRandomId();\\r\\n    this._xPrefix = _config.lockPrefix + '_X_';\\r\\n    this._yPrefix = _config.lockPrefix + '_Y_';\\r\\n\\r\\n    let that = this;\\r\\n    window.addEventListener(\\\"beforeunload\\\", function (ev) {\\r\\n      var arr = [];\\r\\n\\r\\n      for (var i = 0; i < localStorage.length; i++) {\\r\\n        if (localStorage.key(i).indexOf(that._xPrefix) == 0\\r\\n          || localStorage.key(i).indexOf(that._yPrefix) == 0) {\\r\\n          arr.push(localStorage.key(i));\\r\\n        }\\r\\n      }\\r\\n\\r\\n      for (var i = 0; i < arr.length; i++) {\\r\\n        localStorage.removeItem(arr[i]);\\r\\n      }\\r\\n    });\\r\\n  }\\r\\n\\r\\n  public lock(key: string, timeout: number = -1) {\\r\\n    let that = this;\\r\\n\\r\\n    if (timeout == -1) timeout = this._config.timeout;\\r\\n\\r\\n    let xLock = that._xPrefix + key;\\r\\n    let yLock = that._yPrefix + key;\\r\\n\\r\\n    let lockStats: MutexLockStats = new MutexLockStats();\\r\\n\\r\\n    that.resetStats(lockStats);\\r\\n\\r\\n    this._config.debugEnabled ?? console.debug('Attempting to acquire Lock on \\\"%s\\\" using FastMutex instance \\\"%s\\\"', key, this._clientId);\\r\\n\\r\\n    lockStats.acquireStart = new Date().getTime();\\r\\n\\r\\n    //return new Promise(function (resolve, reject) {\\r\\n    return new Observable<MutexLockStats>(subscriber => {\\r\\n      // we need to differentiate between API calls to lock() and our internal\\r\\n      // recursive calls so that we can timeout based on the original lock() and\\r\\n      // not each subsequent call.  Therefore, create a new function here within\\r\\n      // the promise closure that we use for subsequent calls:\\r\\n      let acquireLock = function acquireLock(key) {\\r\\n\\r\\n        that._releaseExpiredLock(xLock);\\r\\n        that._releaseExpiredLock(yLock);\\r\\n\\r\\n        var elapsedTime = new Date().getTime() - lockStats.acquireStart;\\r\\n        if (elapsedTime >= timeout) {\\r\\n          that._config.debugEnabled ?? console.debug('Lock on \\\"%s\\\" could not be acquired within %sms by FastMutex client \\\"%s\\\"', key, timeout, that._clientId);\\r\\n          subscriber.error(new Error('Lock could not be acquired within ' + timeout + 'ms'));\\r\\n        }\\r\\n\\r\\n        that._setItem(xLock, that._clientId, timeout);\\r\\n\\r\\n        // if y exists, another client is getting a lock, so retry in a bit\\r\\n        var lsY = that._getItem(yLock, timeout);\\r\\n        if (lsY) {\\r\\n          that._config.debugEnabled ?? console.debug('Lock exists on Y (%s), restarting...', lsY);\\r\\n          lockStats.restartCount++;\\r\\n          setTimeout(function () {\\r\\n            return acquireLock(key);\\r\\n          }, 10);\\r\\n          return;\\r\\n        }\\r\\n\\r\\n        // ask for inner lock\\r\\n        that._setItem(yLock, that._clientId, timeout);\\r\\n\\r\\n        // if x was changed, another client is contending for an inner lock\\r\\n        var lsX = that._getItem(xLock, timeout);\\r\\n        if (lsX !== that._clientId) {\\r\\n          lockStats.contentionCount++;\\r\\n          that._config.debugEnabled ?? console.debug('Lock contention detected. X=\\\"%s\\\"', lsX);\\r\\n\\r\\n          // Give enough time for critical section:\\r\\n          setTimeout(function () {\\r\\n            lsY = that._getItem(yLock, timeout);\\r\\n            if (lsY === that._clientId) {\\r\\n              // we have a lock\\r\\n              that._config.debugEnabled ?? console.debug('FastMutex client \\\"%s\\\" won the lock contention on \\\"%s\\\"', that._clientId, key);\\r\\n              that.resolveWithStats(subscriber, lockStats);\\r\\n            } else {\\r\\n              // we lost the lock, restart the process again\\r\\n              lockStats.restartCount++;\\r\\n              lockStats.locksLost++;\\r\\n              that._config.debugEnabled ?? console.debug('FastMutex client \\\"%s\\\" lost the lock contention on \\\"%s\\\" to another process (%s). Restarting...', that._clientId, key, lsY);\\r\\n              setTimeout(function () {\\r\\n                return acquireLock(key);\\r\\n              }, 10);\\r\\n            }\\r\\n          }, 100);\\r\\n\\r\\n          return;\\r\\n        }\\r\\n\\r\\n        // no contention:\\r\\n        that._config.debugEnabled ?? console.debug('FastMutex client \\\"%s\\\" acquired a lock on \\\"%s\\\" with no contention', that._clientId, key);\\r\\n        that.resolveWithStats(subscriber, lockStats);\\r\\n      };\\r\\n\\r\\n      acquireLock(key);\\r\\n\\r\\n    });\\r\\n  }\\r\\n\\r\\n  public release(key) {\\r\\n    this._config.debugEnabled ?? console.debug('FastMutex client \\\"%s\\\" is releasing lock on \\\"%s\\\"', this._clientId, key);\\r\\n\\r\\n    let x = this._xPrefix + key;\\r\\n    let y = this._yPrefix + key;\\r\\n    localStorage.removeItem(x);\\r\\n    localStorage.removeItem(y);\\r\\n\\r\\n    //that.lockStats.lockEnd = new Date().getTime();\\r\\n    //that.lockStats.lockDuration = that.lockStats.lockEnd - that.lockStats.lockStart;\\r\\n\\r\\n    //let retStats = angular.copy(that.lockStats);\\r\\n\\r\\n    //that.resetStats();\\r\\n\\r\\n    //return retStats;\\r\\n  }\\r\\n\\r\\n  private _generateRandomId() {\\r\\n    return Math.floor(Math.random() * 10000000000) + '';\\r\\n  }\\r\\n\\r\\n  private resetStats(lockStats: MutexLockStats) {\\r\\n    lockStats.restartCount = 0;\\r\\n    lockStats.locksLost = 0;\\r\\n    lockStats.contentionCount = 0;\\r\\n    lockStats.acquireDuration = 0;\\r\\n    lockStats.acquireStart = null;\\r\\n  }\\r\\n\\r\\n  private resolveWithStats(subscriber: Subscriber<MutexLockStats>, stats: MutexLockStats) {\\r\\n    var currentTime = new Date().getTime();\\r\\n    stats.acquireEnd = currentTime;\\r\\n    stats.acquireDuration = stats.acquireEnd - stats.acquireStart;\\r\\n    stats.lockStart = currentTime;\\r\\n    subscriber.next(stats);\\r\\n    subscriber.complete();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Helper function to wrap all values in an object that includes the time (so\\r\\n   * that we can expire it in the future) and json.stringify's it\\r\\n   */\\r\\n  private _setItem(key, clientId, timeout) {\\r\\n    let lockItem = new LockItem();\\r\\n    lockItem.clientId = clientId;\\r\\n    lockItem.expiresAt = new Date().getTime() + timeout;\\r\\n    return localStorage.setItem(key, JSON.stringify(lockItem));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Helper function to parse JSON encoded values set in localStorage\\r\\n   */\\r\\n  private _getItem(key, timeout) {\\r\\n    var item = localStorage.getItem(key);\\r\\n\\r\\n    if (!item) return null;\\r\\n\\r\\n    var lockItem = <LockItem>JSON.parse(item);\\r\\n    if (new Date().getTime() - lockItem.expiresAt >= timeout) {\\r\\n      this._config.debugEnabled ?? console.debug('FastMutex client \\\"%s\\\" removed an expired record on \\\"%s\\\"', this._clientId, key);\\r\\n      localStorage.removeItem(key);\\r\\n      return null;\\r\\n    }\\r\\n\\r\\n    return lockItem.clientId;\\r\\n  }\\r\\n\\r\\n  private _releaseExpiredLock(key: string){\\r\\n    var item = localStorage.getItem(key);\\r\\n\\r\\n    if (!item) return null;\\r\\n\\r\\n    var lockItem = <LockItem>JSON.parse(item);\\r\\n\\r\\n    if (lockItem.expiresAt <= new Date().getTime()) {\\r\\n      this._config.debugEnabled ?? console.debug('FastMutex auto removed an expired record on \\\"%s\\\"', key);\\r\\n      localStorage.removeItem(key);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"import { ModuleWithProviders, NgModule } from \\\"@angular/core\\\";\\r\\nimport { MutexFastLockConfig } from \\\"./models/mutex-fast-lock-config\\\";\\r\\nimport { MUTEX_FAST_LOCK_CONFIG } from \\\"./mutex-fast-lock-config.injector\\\";\\r\\n\\r\\n@NgModule()\\r\\nexport class MutexFastLockModule {\\r\\n  static forRoot(config: MutexFastLockConfig): ModuleWithProviders<MutexFastLockModule> {\\r\\n\\r\\n    return ({\\r\\n      ngModule: MutexFastLockModule,\\r\\n      providers: [\\r\\n        { provide: MUTEX_FAST_LOCK_CONFIG, useValue: config },\\r\\n      ]\\r\\n    });\\r\\n\\r\\n  }\\r\\n}\\r\\n\",\"/*\\r\\n * Public API Surface of cnet-mutex-fast-lock\\r\\n */\\r\\n\\r\\nexport * from './lib/models/mutex-fast-lock-config';\\r\\nexport * from './lib/models/mutex-lock-stats';\\r\\nexport * from './lib/mutex-fast-lock.service';\\r\\nexport * from './lib/mutex-fast-lock.module';\\r\\n\",\"/**\\n * Generated bundle index. Do not edit.\\n */\\n\\nexport * from './public-api';\\n\"],\"names\":[],\"mappings\":\"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\"}","type":"asset"}]}